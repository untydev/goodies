import test from 'ava'
import * as values from './detail/values.js'
import * as is from './is.js'

test('isUndefined() returns true or false depending on the argument type', (t) => {
  t.true(is.isUndefined(values.undefinedValue))
  t.false(is.isUndefined(values.nullValue))
  t.false(is.isUndefined(values.booleanValue))
  t.false(is.isUndefined(values.integerValue))
  t.false(is.isUndefined(values.numberValue))
  t.false(is.isUndefined(values.NaNValue))
  t.false(is.isUndefined(values.plusInfinityValue))
  t.false(is.isUndefined(values.minusInfinityValue))
  t.false(is.isUndefined(values.stringValue))
  t.false(is.isUndefined(values.arrayValue))
  t.false(is.isUndefined(values.typedArrayValue))
  t.false(is.isUndefined(values.mapValue))
  t.false(is.isUndefined(values.setValue))
  t.false(is.isUndefined(values.objectValue))
  t.false(is.isUndefined(values.classValue))
  t.false(is.isUndefined(values.functionValue))
  t.false(is.isUndefined(values.symbolValue))
  t.false(is.isUndefined(values.promiseValue))
})

test('isDefined() returns true or false depending on the argument type', (t) => {
  t.false(is.isDefined(values.undefinedValue))
  t.true(is.isDefined(values.nullValue))
  t.true(is.isDefined(values.booleanValue))
  t.true(is.isDefined(values.integerValue))
  t.true(is.isDefined(values.numberValue))
  t.true(is.isDefined(values.NaNValue))
  t.true(is.isDefined(values.plusInfinityValue))
  t.true(is.isDefined(values.minusInfinityValue))
  t.true(is.isDefined(values.stringValue))
  t.true(is.isDefined(values.arrayValue))
  t.true(is.isDefined(values.typedArrayValue))
  t.true(is.isDefined(values.mapValue))
  t.true(is.isDefined(values.setValue))
  t.true(is.isDefined(values.objectValue))
  t.true(is.isDefined(values.classValue))
  t.true(is.isDefined(values.functionValue))
  t.true(is.isDefined(values.symbolValue))
  t.true(is.isDefined(values.promiseValue))
})

test('isNull() returns true or false depending on the argument type', (t) => {
  t.false(is.isNull(values.undefinedValue))
  t.true(is.isNull(values.nullValue))
  t.false(is.isNull(values.booleanValue))
  t.false(is.isNull(values.integerValue))
  t.false(is.isNull(values.numberValue))
  t.false(is.isNull(values.NaNValue))
  t.false(is.isNull(values.plusInfinityValue))
  t.false(is.isNull(values.minusInfinityValue))
  t.false(is.isNull(values.stringValue))
  t.false(is.isNull(values.arrayValue))
  t.false(is.isNull(values.typedArrayValue))
  t.false(is.isNull(values.mapValue))
  t.false(is.isNull(values.setValue))
  t.false(is.isNull(values.objectValue))
  t.false(is.isNull(values.classValue))
  t.false(is.isNull(values.functionValue))
  t.false(is.isNull(values.symbolValue))
  t.false(is.isNull(values.promiseValue))
})

test('isBoolean() returns true or false depending on the argument type', (t) => {
  t.false(is.isBoolean(values.undefinedValue))
  t.false(is.isBoolean(values.nullValue))
  t.true(is.isBoolean(values.booleanValue))
  t.false(is.isBoolean(values.integerValue))
  t.false(is.isBoolean(values.numberValue))
  t.false(is.isBoolean(values.NaNValue))
  t.false(is.isBoolean(values.plusInfinityValue))
  t.false(is.isBoolean(values.minusInfinityValue))
  t.false(is.isBoolean(values.stringValue))
  t.false(is.isBoolean(values.arrayValue))
  t.false(is.isBoolean(values.typedArrayValue))
  t.false(is.isBoolean(values.mapValue))
  t.false(is.isBoolean(values.setValue))
  t.false(is.isBoolean(values.objectValue))
  t.false(is.isBoolean(values.classValue))
  t.false(is.isBoolean(values.functionValue))
  t.false(is.isBoolean(values.symbolValue))
  t.false(is.isBoolean(values.promiseValue))
})

test('isInteger() returns true or false depending on the argument type', (t) => {
  t.false(is.isInteger(values.undefinedValue))
  t.false(is.isInteger(values.nullValue))
  t.false(is.isInteger(values.booleanValue))
  t.true(is.isInteger(values.integerValue))
  t.false(is.isInteger(values.numberValue))
  t.false(is.isInteger(values.NaNValue))
  t.false(is.isInteger(values.plusInfinityValue))
  t.false(is.isInteger(values.minusInfinityValue))
  t.false(is.isInteger(values.stringValue))
  t.false(is.isInteger(values.arrayValue))
  t.false(is.isInteger(values.typedArrayValue))
  t.false(is.isInteger(values.mapValue))
  t.false(is.isInteger(values.setValue))
  t.false(is.isInteger(values.objectValue))
  t.false(is.isInteger(values.classValue))
  t.false(is.isInteger(values.functionValue))
  t.false(is.isInteger(values.symbolValue))
  t.false(is.isInteger(values.promiseValue))
})

test('isNumber() returns true or false depending on the argument type', (t) => {
  t.false(is.isNumber(values.undefinedValue))
  t.false(is.isNumber(values.nullValue))
  t.false(is.isNumber(values.booleanValue))
  t.true(is.isNumber(values.integerValue))
  t.true(is.isNumber(values.numberValue))
  t.false(is.isNumber(values.NaNValue))
  t.false(is.isNumber(values.plusInfinityValue))
  t.false(is.isNumber(values.minusInfinityValue))
  t.false(is.isNumber(values.stringValue))
  t.false(is.isNumber(values.arrayValue))
  t.false(is.isNumber(values.typedArrayValue))
  t.false(is.isNumber(values.mapValue))
  t.false(is.isNumber(values.setValue))
  t.false(is.isNumber(values.objectValue))
  t.false(is.isNumber(values.classValue))
  t.false(is.isNumber(values.functionValue))
  t.false(is.isNumber(values.symbolValue))
  t.false(is.isNumber(values.promiseValue))
})

test('isString() returns true or false depending on the argument type', (t) => {
  t.false(is.isString(values.undefinedValue))
  t.false(is.isString(values.nullValue))
  t.false(is.isString(values.booleanValue))
  t.false(is.isString(values.integerValue))
  t.false(is.isString(values.numberValue))
  t.false(is.isString(values.NaNValue))
  t.false(is.isString(values.plusInfinityValue))
  t.false(is.isString(values.minusInfinityValue))
  t.true(is.isString(values.stringValue))
  t.false(is.isString(values.arrayValue))
  t.false(is.isString(values.typedArrayValue))
  t.false(is.isString(values.mapValue))
  t.false(is.isString(values.setValue))
  t.false(is.isString(values.objectValue))
  t.false(is.isString(values.classValue))
  t.false(is.isString(values.functionValue))
  t.false(is.isString(values.symbolValue))
  t.false(is.isString(values.promiseValue))
})

test('isArray() returns true or false depending on the argument type', (t) => {
  t.false(is.isArray(values.undefinedValue))
  t.false(is.isArray(values.nullValue))
  t.false(is.isArray(values.booleanValue))
  t.false(is.isArray(values.integerValue))
  t.false(is.isArray(values.numberValue))
  t.false(is.isArray(values.NaNValue))
  t.false(is.isArray(values.plusInfinityValue))
  t.false(is.isArray(values.minusInfinityValue))
  t.false(is.isArray(values.stringValue))
  t.true(is.isArray(values.arrayValue))
  t.false(is.isArray(values.typedArrayValue))
  t.false(is.isArray(values.mapValue))
  t.false(is.isArray(values.setValue))
  t.false(is.isArray(values.objectValue))
  t.false(is.isArray(values.classValue))
  t.false(is.isArray(values.functionValue))
  t.false(is.isArray(values.symbolValue))
  t.false(is.isArray(values.promiseValue))
})

test('isFunction() returns true or false depending on the argument type', (t) => {
  t.false(is.isFunction(values.undefinedValue))
  t.false(is.isFunction(values.nullValue))
  t.false(is.isFunction(values.booleanValue))
  t.false(is.isFunction(values.integerValue))
  t.false(is.isFunction(values.numberValue))
  t.false(is.isFunction(values.NaNValue))
  t.false(is.isFunction(values.plusInfinityValue))
  t.false(is.isFunction(values.minusInfinityValue))
  t.false(is.isFunction(values.stringValue))
  t.false(is.isFunction(values.arrayValue))
  t.false(is.isFunction(values.typedArrayValue))
  t.false(is.isFunction(values.mapValue))
  t.false(is.isFunction(values.setValue))
  t.false(is.isFunction(values.objectValue))
  t.false(is.isFunction(values.classValue))
  t.true(is.isFunction(values.functionValue))
  t.false(is.isFunction(values.symbolValue))
  t.false(is.isFunction(values.promiseValue))
})

test('isObject() returns true or false depending on the argument type', (t) => {
  t.false(is.isObject(values.undefinedValue))
  t.false(is.isObject(values.nullValue))
  t.false(is.isObject(values.booleanValue))
  t.false(is.isObject(values.integerValue))
  t.false(is.isObject(values.numberValue))
  t.false(is.isObject(values.NaNValue))
  t.false(is.isObject(values.plusInfinityValue))
  t.false(is.isObject(values.minusInfinityValue))
  t.false(is.isObject(values.stringValue))
  t.true(is.isObject(values.arrayValue))
  t.true(is.isObject(values.typedArrayValue))
  t.true(is.isObject(values.mapValue))
  t.true(is.isObject(values.setValue))
  t.true(is.isObject(values.objectValue))
  t.true(is.isObject(values.classValue))
  t.false(is.isObject(values.functionValue))
  t.false(is.isObject(values.symbolValue))
  t.true(is.isObject(values.promiseValue))
})

test('isIterable() returns true or false depending on the argument type', (t) => {
  t.false(is.isIterable(values.undefinedValue))
  t.false(is.isIterable(values.nullValue))
  t.false(is.isIterable(values.booleanValue))
  t.false(is.isIterable(values.integerValue))
  t.false(is.isIterable(values.numberValue))
  t.false(is.isIterable(values.NaNValue))
  t.false(is.isIterable(values.plusInfinityValue))
  t.false(is.isIterable(values.minusInfinityValue))
  t.true(is.isIterable(values.stringValue))
  t.true(is.isIterable(values.arrayValue))
  t.true(is.isIterable(values.typedArrayValue))
  t.true(is.isIterable(values.mapValue))
  t.true(is.isIterable(values.setValue))
  t.false(is.isIterable(values.objectValue))
  t.false(is.isIterable(values.classValue))
  t.false(is.isIterable(values.functionValue))
  t.false(is.isIterable(values.symbolValue))
  t.false(is.isIterable(values.promiseValue))
})

test('isSymbol() returns true or false depending on the argument type', (t) => {
  t.false(is.isSymbol(values.undefinedValue))
  t.false(is.isSymbol(values.nullValue))
  t.false(is.isSymbol(values.booleanValue))
  t.false(is.isSymbol(values.integerValue))
  t.false(is.isSymbol(values.numberValue))
  t.false(is.isSymbol(values.NaNValue))
  t.false(is.isSymbol(values.plusInfinityValue))
  t.false(is.isSymbol(values.minusInfinityValue))
  t.false(is.isSymbol(values.stringValue))
  t.false(is.isSymbol(values.arrayValue))
  t.false(is.isSymbol(values.typedArrayValue))
  t.false(is.isSymbol(values.mapValue))
  t.false(is.isSymbol(values.setValue))
  t.false(is.isSymbol(values.objectValue))
  t.false(is.isSymbol(values.classValue))
  t.false(is.isSymbol(values.functionValue))
  t.true(is.isSymbol(values.symbolValue))
  t.false(is.isSymbol(values.promiseValue))
})

test('isPromise() returns true or false depending on the argument type', (t) => {
  t.false(is.isPromise(values.undefinedValue))
  t.false(is.isPromise(values.nullValue))
  t.false(is.isPromise(values.booleanValue))
  t.false(is.isPromise(values.integerValue))
  t.false(is.isPromise(values.numberValue))
  t.false(is.isPromise(values.NaNValue))
  t.false(is.isPromise(values.plusInfinityValue))
  t.false(is.isPromise(values.minusInfinityValue))
  t.false(is.isPromise(values.stringValue))
  t.false(is.isPromise(values.arrayValue))
  t.false(is.isPromise(values.typedArrayValue))
  t.false(is.isPromise(values.mapValue))
  t.false(is.isPromise(values.setValue))
  t.false(is.isPromise(values.objectValue))
  t.false(is.isPromise(values.classValue))
  t.false(is.isPromise(values.functionValue))
  t.false(is.isPromise(values.symbolValue))
  t.true(is.isPromise(values.promiseValue))
})
